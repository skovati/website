<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on skovati</title>
    <link>https://skovati.dev/tags/linux/</link>
    <description>Recent content in linux on skovati</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Dec 2021 10:09:54 -0500</lastBuildDate>
    
	<atom:link href="https://skovati.dev/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why Unix?</title>
      <link>https://skovati.dev/blog/whyunix/</link>
      <pubDate>Sun, 05 Dec 2021 10:09:54 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/whyunix/</guid>
      <description>&lt;p&gt;This post is meant to be inspiration to those considering using a unix-like system (I&amp;rsquo;m mainly referring to a Linux distro or one of the BSDs) similar to my &lt;a href=&#34;../blog/whyvim.md&#34;&gt;Why Vim?&lt;/a&gt; post.&lt;/p&gt;
&lt;p&gt;The first set of blog posts I made on this website were about the history of unix/linux, and how to get started experimenting with these systems. However, I got carried away and turned this into a multi part saga, so this post will attempt to condense these thoughts into a standalone post about why &lt;em&gt;you&lt;/em&gt; should use this flavor of operating system.&lt;/p&gt;
&lt;p&gt;Note: I&amp;rsquo;ll often say Linux here, but most of what I say applies to *BSD and other unix-like systems.&lt;/p&gt;
&lt;h2 id=&#34;freedom-and-philosophy&#34;&gt;Freedom and Philosophy&lt;/h2&gt;
&lt;p&gt;Unix systems are often synonymous with the Free and Open Source Software movement, henceforth referred to as FOSS. Open source means the source code is available to the public, so you can go ahead and browse the &lt;a href=&#34;https://github.com/torvalds/linux/&#34;&gt;Linux source code&lt;/a&gt; to see exactly how the networking drivers work or how virtual memory is managed. While this might not interest &lt;em&gt;you&lt;/em&gt; specifically, having source code available and open to the public means security experts can audit the code for security bugs, experienced programmers can code up new features and merge them into the project, or you can simply be sure the code isn&amp;rsquo;t doing anything nefarious like selling your data to advertisers.&lt;/p&gt;
&lt;p&gt;FOSS also means the software is &amp;ldquo;free&amp;rdquo; or &amp;ldquo;libre&amp;rdquo;, meaning you are often legally allowed and encouraged to copy the code and make your own version (often called a &amp;ldquo;fork&amp;rdquo;) and distribute your version. This means hacking on the system and making it exactly how you want is highly encouraged and this is a driving factor behind the rich Linux community.&lt;/p&gt;
&lt;p&gt;Unix-like operating systems are also free as in there is no license you have to pay for in order to use the software. No more calling Microsoft to try and get your expired Windows license extended.&lt;/p&gt;
&lt;h2 id=&#34;modularity-and-customization&#34;&gt;Modularity and Customization&lt;/h2&gt;
&lt;p&gt;The beauty of unix systems (and here this excludes macOS) is their modularity and extensibility. Linux is just the kernel, and so requires many other programs like desktop environments, networking management, user utilities, web browsers, and more to become a usable operating system. In Windows or macOS, these choices are made for you, and you are given one document viewer, one video player, one default web browser, one desktop environment, one file manager, etc. While many of these things can be changed (ie most people switch to use Google Chrome), the developers of these proprietary OS&amp;rsquo;s &lt;strong&gt;want&lt;/strong&gt; you to stay in their walled garden, and actively discourage heavily customizing your setup and messing around.&lt;/p&gt;
&lt;p&gt;Linux systems are in stark contrast to this idea. If you don&amp;rsquo;t like something about your setup, change it! There are &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_Linux_distributions&#34;&gt;thousands&lt;/a&gt; of Linux distributions (distros) that each cater to a different audience. Want a stable OS to run a minecraft server on that old laptop of yours? Check out &lt;a href=&#34;https://www.debian.org/&#34;&gt;Debian&lt;/a&gt;! Interested in a bleeding edge gaming setup for your new build? Check out &lt;a href=&#34;https://archlinux.org/&#34;&gt;Archlinux&lt;/a&gt;! The list goes on and on&amp;hellip; point being that instead of trying to make a one-size-fits-all, jack of all trades master of none OS like Windows or macOS, unix systems embrace this modularity and let the user choose what they want. This reason extends to every piece of software you&amp;rsquo;ll use on a Linux system; you can choose from desktop environments and window managers and more to give you the exact customized experience you&amp;rsquo;re looking for. While this does take more time up front choosing software you want to use, it pays off in the long run when you get to use the exact setup you want everyday. I personally use a customized tiling window manager called &lt;a href=&#34;https://dwm.suckless.org&#34;&gt;dwm&lt;/a&gt; that has vastly improved my programming/note-taking workflow&amp;hellip; no chance I could get something like that running on Windows easily.&lt;/p&gt;
&lt;h2 id=&#34;extensibility&#34;&gt;Extensibility&lt;/h2&gt;
&lt;p&gt;Unix systems are also famously extensible, meaning functionality that wasn&amp;rsquo;t explicitly programmed in by the original devs can easily be added on. This is often done through the use of plain text. Yes that&amp;rsquo;s right, plain text. Unix treats everything, from attached devices like your monitor or keyboard, to system settings, to the contents of memory, as a text file. So, if programs agree to take plain text as input and output more plain text, they can be linked together and interact with the system in ways that weren&amp;rsquo;t explicitly programmed in. This may sound like gibberish, but offers essentially unlimited possibilities. A simple example is something like the backlight brightness for your laptop. In Windows this brightness value is stored in some arcane location that is only meant to be changed through the official settings app, but in Linux this is simply a number stored in a text file in /sys/class/backlight/*/brightness, so you could easily write a small script or program to, for example, dim the screen after 7pm by writing a new number to that file. In Windows however, this functionality would have to have been explicitly programmed in by some developer at Microsoft, so if they didn&amp;rsquo;t implement screen dimming the way you like you&amp;rsquo;re out of luck. This is a trivial example but hopefully explains the idea of extensibility in unix systems through text interfaces, an idea that can be applied to much more complex problems.&lt;/p&gt;
&lt;h2 id=&#34;scripting-and-automation&#34;&gt;Scripting and Automation&lt;/h2&gt;
&lt;p&gt;I often hear the sentiment that the terminal is &amp;ldquo;only for hackers&amp;rdquo; or similar, but this is far from the truth. Since plain text is the common interface within unix-like systems, the terminal (and shell scripting as an extension of that) is simply the most powerful way to interact with your system. As previously stated, if you want some feature in an graphical application, it has to be &lt;em&gt;explicitly&lt;/em&gt; placed there by the author, ie you can&amp;rsquo;t click the button if it wasn&amp;rsquo;t programmed in the first place. However, on unix systems, programs often input and output text, which you can directly access and modify on the command line.&lt;/p&gt;
&lt;p&gt;Maybe, for example, your graphical note-taking application doesn&amp;rsquo;t have a &amp;ldquo;sort alphabetically&amp;rdquo; feature for lists. You&amp;rsquo;d be out of luck within the confines of that one application normally, but if you could either export to or originally write in a plain text format, you could simply take the output of your notes and use it as input to a command line program like &lt;code&gt;sort&lt;/code&gt;, which will output your notes sorted alphabetically. Better yet, you could write a small shell script (which is a script file with terminal commands meant to be automatically run) to automate this for you, so your to-do list is always sorted! This kind of extensibility and automation is native to the command line; it&amp;rsquo;s much harder to automate clicking a button in a graphical user interface.&lt;/p&gt;
&lt;p&gt;Essentially, since unix-systems use text as the common interface between programs and devices, and the since terminal is the most effective way to work with and manipulate that text, their combination is extremely powerful and gives you control over your system and the ability to automate things easily.&lt;/p&gt;
&lt;h2 id=&#34;lightweight-and-minimal&#34;&gt;Lightweight and Minimal&lt;/h2&gt;
&lt;p&gt;The fact that Windows installs Candy Crush by default should be reason enough to ditch it, but in general unix OS&amp;rsquo;s are extremely lightweight compared to Windows or macOS. If you&amp;rsquo;re running on lower end or older hardware, a lightweight Linux distro can breathe new life into your computer. Currently, my system uses 180 MB of memory idle, compared to several &lt;em&gt;gigabytes&lt;/em&gt; used by an &amp;ldquo;idle&amp;rdquo; Windows system. While I do happen to take this to the extreme with minimal software, it just goes to show &lt;em&gt;how much&lt;/em&gt; more bloat and unnecessary software is running on your average Windows install.&lt;/p&gt;
&lt;h2 id=&#34;privacy-security-and-reliability&#34;&gt;Privacy, Security, and Reliability&lt;/h2&gt;
&lt;p&gt;Using a FOSS operating system like Linux or BSD is a breath of fresh air in the modern digital age where companies mine as much data as possible to track you or sell to advertisers. This simply isn&amp;rsquo;t an issue, since Linux and other unix-like OS&amp;rsquo;s don&amp;rsquo;t have a toxic business model that requires monetization of everything. No more Cortana listening to you signing to yourself or Apple shoving their new TV streaming service down your throat.&lt;/p&gt;
&lt;p&gt;Unix systems are also often more secure, as companies like Google and Amazon heavily invest in security within the Linux kernel that runs the YouTube servers and AWS services that the internet depends on. The open source model also means security experts can audit and fix any bugs or exploits early and out in the open.&lt;/p&gt;
&lt;p&gt;And speaking of Linux running on servers, a massive chunk of modern digital infrastructure runs on these OS&amp;rsquo;s. Everything from your WiFi router to cell phone to car to your bank account is run on Linux or a Unix-like operating system. The reliability of Unix systems that can be trusted to run the world&amp;rsquo;s economy; why wouldn&amp;rsquo;t you want that reliability on your personal laptop too?&lt;/p&gt;
&lt;h2 id=&#34;package-management&#34;&gt;Package Management&lt;/h2&gt;
&lt;p&gt;Package managers originated in unix-like operating systems, although there is a large effort to get them on Windows and macOS because they&amp;rsquo;re so awesome. If you aren&amp;rsquo;t familiar, a package manager is Unix&amp;rsquo;s way of installing, managing, and removing software. Normally on a Windows or macOS install, if you wanted to install, for example, the spotify desktop app, you&amp;rsquo;d open a web brower, search for spotify, go to their website, download the latest version, run the executable that installs the program, and finally open it. On Linux, you can run one simple command instead &lt;code&gt;apt install spotify&lt;/code&gt;. These package managers are created and maintained by the distribution you&amp;rsquo;re using&lt;/p&gt;
&lt;h2 id=&#34;education-and-enjoyment&#34;&gt;Education and Enjoyment&lt;/h2&gt;
&lt;p&gt;Lastly, using a unix-like operating system is just &lt;em&gt;fun&lt;/em&gt;. You&amp;rsquo;ll learn new things, think about problems from a new perspective, find a vibrant and friendly online community, and even brush up on technical skills that are useful on the job. You likely already know your way around your current OS, so why not give something new a try and keep learning?&lt;/p&gt;
&lt;h2 id=&#34;where-to-now&#34;&gt;Where to now?&lt;/h2&gt;
&lt;p&gt;Install Linux! I have an overview of how to get started &lt;a href=&#34;../linux/intro/ch3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description> 
    </item>
    
    <item>
      <title>Intro to Linux - Chapter 6</title>
      <link>https://skovati.dev/blog/linux/intro/ch6/</link>
      <pubDate>Tue, 25 May 2021 18:00:53 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/linux/intro/ch6/</guid>
      <description>&lt;h2 id=&#34;bash--extensibility&#34;&gt;Bash &amp;amp;&amp;amp; Extensibility&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Author: Skovati, Date: 2020-12-29&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So what &lt;em&gt;is&lt;/em&gt; bash? It stands for Bourne Again Shell, and is a rewrite and play on words of the original Bourne shell (sh) written by Stephen Bourne at Bell Labs. It is mainly used as an interactive command line interpreter. When you login to a Unix-based system, or open a terminal, you&amp;rsquo;ll be greeted by a prompt that looks something like &lt;code&gt;[username@hostname ~]$&lt;/code&gt;. Here you can run any of the GNU system utility commands. Here is a short list of important commands you should know.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; - LiSts the files and directories in the current directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; - Changes the Directory you are in, eg &lt;code&gt;cd downloads&lt;/code&gt; would move you to your downloads directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt; - MaKes a DIRectory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;man&lt;/code&gt; - prefixing this to another command shows the MANual page for that command—this is &lt;em&gt;the&lt;/em&gt; best way to learn about a program quickly&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch&lt;/code&gt; - TOUCHes a file to update its metadata, or will create an empty file if it doesn&amp;rsquo;t exist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat&lt;/code&gt; - conCATenate the files passed to it and prints them. Commonly used to view the contents of a text file quickly.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mv&lt;/code&gt; - MoVes argument 1 to argument 2, eg &lt;code&gt;mv resume_current.pdf resume_old.pdf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp&lt;/code&gt; - CoPies argument 1 to argument 2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm&lt;/code&gt; - ReMoves a file or directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pwd&lt;/code&gt; - Prints Working Directory, prints the directory you&amp;rsquo;re currently in&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nano&lt;/code&gt; - GNU text editor, pass a file to it to edit, perfect for editing configuration files.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These commands will likely make up the majority of what you run, as they help you move around the filesystem and edit files on the command line. Really the best way to get familiar with these commands and more is to use the terminal as often as you can! Personally, I exclusively use the terminal to edit files—I&amp;rsquo;m currently writing this in Vim, a terminal based text editor.&lt;/p&gt;
&lt;p&gt;Every time you run a command in bash, it&amp;rsquo;s actually calling a pre-compiled C program binary located at /bin or /usr/bin. You can see the path of the executed binary with the &lt;code&gt;which&lt;/code&gt; command. For example, running &lt;code&gt;which ls&lt;/code&gt; outputs /usr/bin/ls, which is the small executable that bash is calling every time I run that command.&lt;/p&gt;
&lt;p&gt;Bash is more than just a command line interpreter however, it&amp;rsquo;s actually a full scripting language with control flow, variables, and functions. While these features &lt;em&gt;could&lt;/em&gt; be used on the command line, they&amp;rsquo;re most commonly used in a &lt;em&gt;shell script&lt;/em&gt;, which has a .sh extension, and can be executed by the bash shell. Personally, I have dozens of small bash scripts to do things like update my system, quickly find and edit files, connect to vpns and more. A decent rule of thumb for when something should be converted to a shell script is if you find yourself running a series of commands in a row multiple times a day, turn those commands into a small shell script that bash can execute for you. For example, I&amp;rsquo;m writing this blog in Markdown, and using Pandoc to convert that to html so my web server can host it. Essentially, the output of pandoc has to be concatenated with a template.html file I have, and then I have to concatenate that index.html output with a closing article tag so it&amp;rsquo;s valid html. So, instead of running that set of commands multiple times, I wrote the following shell script to speed things up.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash

cp -v /home/skovati/code/git/skovati.com/blog/template.html ./index.html
pandoc $1 -f markdown -t html &amp;gt;&amp;gt; ./index.html
echo &amp;quot;&amp;lt;/article&amp;gt;&amp;quot; &amp;gt;&amp;gt; ./index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each of those lines &lt;em&gt;could&lt;/em&gt; just be pasted into a regular bash prompt, and it would work the same, but the script saves you a lot of time. The first line there just tells the bash interpreter to run the script. Then I copy my template html file to the current chapter folder, convert the chapters markdown to html and add it to the end of the template html file, and finally add that closing article tag. Now, I can just run &lt;code&gt;convert ch6.md&lt;/code&gt; and it&amp;rsquo;ll output a correctly formatted html file for my server to host.&lt;/p&gt;
&lt;p&gt;Bash scripting should (and probably will be) its own chapter, but I want to show off a few &lt;em&gt;really&lt;/em&gt; cool things it can do. First, you should be familiar with standard input and output. Stdin is essentially a stream of text that can be sent to a program, and stdout is a stream of text that a program can output. On Unix-based systems, we can use these in combination with the Unix Philosophy of each program doing one thing and doing it well, to chain together programs. Here&amp;rsquo;s an example.&lt;/p&gt;
&lt;p&gt;Running &lt;code&gt;ls&lt;/code&gt; in my current directory prints out three directories: code, documents, and downloads. Say, for example, I wanted to count how many files and directories were output by that &lt;code&gt;ls&lt;/code&gt; command. Here, we can use &amp;ldquo;pipes&amp;rdquo; by placing the &amp;ldquo;|&amp;rdquo; symbol in-between &lt;code&gt;ls&lt;/code&gt; and another command that counts the number of lines in a text stream, &lt;code&gt;wc -l&lt;/code&gt;. So, the full bash command would look like &lt;code&gt;ls | wc -l&lt;/code&gt; which would output 3, since there were just those three files. Say now I wanted to check the number of installed binary programs on my system, I could just run &lt;code&gt;ls /usr/bin | wc -l&lt;/code&gt; which outputs 3490.&lt;/p&gt;
&lt;p&gt;This introduces the idea of extensibility. Since these GNU system utilities simply take in a text stream and then output a text stream, they can easily communicate with each other, which creates new possibilities that the developers of either program didn&amp;rsquo;t have to explicitly program. Here&amp;rsquo;s a more useful example of this text-based extensibility in action:&lt;/p&gt;
&lt;p&gt;As previously mentioned, I&amp;rsquo;m writing these blog posts in Markdown, which is just a text file with some simple syntax to show &lt;strong&gt;bold&lt;/strong&gt; words or &lt;em&gt;italics&lt;/em&gt; and stuff like that. Since all the posts are text, I can run cat on all of them to output them all to a big text stream. Then, I could pipe that into another program, like word count, to see more information about all the blog posts. Running &lt;code&gt;cat ch*/*.md | wc -w&lt;/code&gt; (the *&amp;rsquo;s just mean to select every .md file) outputs 7288, so that&amp;rsquo;s how many words I&amp;rsquo;ve written in the last 5 blog posts! Going deeper, I could count up how many times I&amp;rsquo;ve said the word &amp;ldquo;Linux&amp;rdquo; with a command like this &lt;code&gt;cat ch*/*.md | grep -wo Linux | wc -l&lt;/code&gt; (grep is a tool for searching text streams) which outputs 90. If I was instead writing all of these in something like Microsoft Word, I&amp;rsquo;d have to open up each file manually, Ctrl-f to search for Linux, and then count up and add together all of the instances manually. &lt;em&gt;That&amp;rsquo;s&lt;/em&gt; the power of Linux.&lt;/p&gt;
</description> 
    </item>
    
    <item>
      <title>Intro to Linux - Chapter 5</title>
      <link>https://skovati.dev/blog/linux/intro/ch5/</link>
      <pubDate>Tue, 25 May 2021 18:00:51 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/linux/intro/ch5/</guid>
      <description>&lt;h2 id=&#34;chapter-5---server-configuration&#34;&gt;Chapter 5 - Server Configuration&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Author: Skovati, Date: 2020-12-29&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This chapter is optional if you&amp;rsquo;re strictly using Linux as a desktop OS, but goes over some useful ideas like user management and security that are still applicable.&lt;/p&gt;
&lt;h3 id=&#34;ssh-keys&#34;&gt;SSH Keys&lt;/h3&gt;
&lt;p&gt;First of all, what &lt;em&gt;is&lt;/em&gt; SSH? It stands for Secure Shell, and is a protocol design to gain remote shell access to Linux servers. All traffic is encrypted by default, and the popular OpenSSH implementation of the protocol is one of the most secure pieces of software that exists. You can authenticate through SSH in a few ways, one of which being just your username and password on the server, like &lt;code&gt;ssh username@server-ip&lt;/code&gt;, which will prompt you for your user&amp;rsquo;s password on that server, and then give you access if it was correct. This is relatively insecure, since lots of cloud based servers will accept SSH requests from any IP, meaning anyone can try and guess your password to gain access to your server. To mitigate this, I recommend the use of SSH public/private key pairs for authentication. If you aren&amp;rsquo;t familiar with public key cryptography—you should be, here&amp;rsquo;s a very brief primer.&lt;/p&gt;
&lt;p&gt;Using advanced number theory, an algorithm generates two keys—one public and one private—that are cryptographically linked, such that using your private key to login to a server that has your public key on a whitelist with authenticate you and essentially guarantee you are who you say you are—that is, if you&amp;rsquo;re responsible with your private key and keep it &lt;em&gt;private&lt;/em&gt;. Guessing someone else&amp;rsquo;s private key takes somewhere on the order of 2^256 guesses, which is significantly more secure than using an 8 digit password to authenticate. I recommend &lt;a href=&#34;https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/&#34;&gt;reading&lt;/a&gt; and &lt;a href=&#34;https://www.youtube.com/watch?v=GSIDS_lvRv4&#34;&gt;watching&lt;/a&gt; some more resources to get a good understanding. Essentially all you need to know to use SSH keys, is that a really long, really secure password is generated for you and stored in a file, and you&amp;rsquo;ll use that &amp;ldquo;password&amp;rdquo; (private key) to login to your server. The server, which will have your public key in an &amp;ldquo;authorized keys&amp;rdquo; list, will then check for a cryptographic match between SSH requests with different private keys to see if it matches a key in this authorized list. If it does, you are given access.&lt;/p&gt;
&lt;p&gt;Because of this vastly increased security, myself, and cloud VM providers like Google Cloud, &lt;em&gt;only&lt;/em&gt; recommend the use of SSH keys for authentication, and encourage disabling password authentication entirely to increase security. We&amp;rsquo;ll learn how to do that after we generate some SSH keys.&lt;/p&gt;
&lt;p&gt;On both Linux and Windows, to generate SSH key pairs, run the command &lt;code&gt;ssh-keygen&lt;/code&gt;, which will launch an interactive generation program. Selecting the defaults here is alright until you learn a little more, but I&amp;rsquo;d recommend using a 4096 bit RSA key for increased security, as shorter keys like 1024 bit have shown weaknesses. Once generated, your public key will live at either /home/&lt;em&gt;username&lt;/em&gt;/.ssh/id_rsa.pub or C:\Users\&lt;em&gt;username&lt;/em&gt;\.ssh\id_rsa.pub on Linux and Windows respectively. Your private key will be the file there without the .pub extension. If you&amp;rsquo;re following the GCP guide from Chapter 4, go back and read the next part to add it to your VMs whitelist. If you&amp;rsquo;re setting up a Linux server manually, edit your users ~/.ssh/authorized_keys file and paste your public key there.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;user-management-and-the-root-user&#34;&gt;User Management and the Root User&lt;/h3&gt;
&lt;p&gt;User management on Linux is fantastically simple. Each user has a home directory located at /home/&lt;em&gt;username&lt;/em&gt;/ (the first / refers to the root of the filesystem, similar to C:/ in Windows), where all of the user-specific configuration files, media, downloads, cached Spotify music, and much more. Users can belong to groups too; each user is automatically a member of a group with the same name as the username. Files and directories can be &amp;ldquo;owned&amp;rdquo; by one user, and one group at a time, and each file and directory has certain permissions that say which user or group can read, edit, or execute the given file or directory. We&amp;rsquo;ll learn about filesystems and permissions more in a later chapter. The most important group is the sudo group (also known as the wheel group), which allows any user in the sudo group to use the sudo command.&lt;/p&gt;
&lt;p&gt;For those who aren&amp;rsquo;t familiar, the root user on Linux is like the Administrator. The root user runs all the low level services, installs system-wide packages, makes important configuration changes, and can access any information on the system. Because of this extreme power, it isn&amp;rsquo;t recommended to login and use the system as the root user for long periods of time, as you can easily break things since you have no limitations. But, often a regular user will need root access in order to say, install a new package like Firefox, or add a new VPN connection. To remedy this, we use the &lt;code&gt;sudo&lt;/code&gt; command, which when prefixed to another command, will run that other command as the root user. This is the reason you must run &lt;code&gt;sudo apt install firefox&lt;/code&gt; rather than just &lt;code&gt;apt install firefox&lt;/code&gt;, since you are installing a system-wide package that can affect other users. Only certain users, which could be considered administrators, will have the ability to use this &lt;code&gt;sudo&lt;/code&gt; command. These administrator users are put in the sudo group, so that they can run commands as root.&lt;/p&gt;
&lt;p&gt;This whole user system will make more sense as you gain experience using Linux, but make sure your user is in the sudo group and is able to run commands as root. On GCP, I believe your user is automatically in the sudo group, but doesn&amp;rsquo;t have a password. If you want to add a password, run the command &lt;code&gt;sudo su&lt;/code&gt; (su is a command that lets you switch to be a different user, when run with no arguments it switches you to the root user) and then run &lt;code&gt;passwd your-username&lt;/code&gt;, which will prompt you for a new password. Then  type &lt;code&gt;exit&lt;/code&gt; to stop being the root user. Test your sudo access by running something like &lt;code&gt;sudo apt update&lt;/code&gt;. If your root access checks out, we can move onto the next steps of configuration.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;hardening-your-server-with-ssh-configurations-and-a-firewall&#34;&gt;Hardening your server with SSH configurations and a Firewall&lt;/h3&gt;
&lt;p&gt;Time to edit our first configuration file! Once you&amp;rsquo;re sure your SSH key auth is working, it&amp;rsquo;s time to disable password-based logins and remote root login in order to secure our server. The configuration file for the SSH daemon (a daemon is like a background service) is located at /etc/ssh/sshd_config. Open this with &lt;code&gt;sudo nano /etc/ssh/sshd_config&lt;/code&gt;. Scroll down using the arrow keys and find the commented option called PermitRootLogin, uncomment this, and set it to &amp;ldquo;no&amp;rdquo;. Next find the option PubkeyAuthentication and set it to yes. Finally find the option, PasswordAuthentication and set it to no. Then, exit and save the file by pressing Ctrl-X, Y, and then enter. Finally, we must restart the SSH daemon with the command &lt;code&gt;sudo systemctl restart sshd&lt;/code&gt; (systemctl is the command used to interact with system processes and daemons). Congrats! You just edited your first system configuration file and applied it. I know that was kind of a lot, but taking these few steps just made your system significantly more secure.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re running a server with a public IP address, I recommend running a firewall on it. Normally, a networks router or dedicated firewall will block unauthorized packets, but having a per-server firewall is recommended. If you&amp;rsquo;re running a GCP VM, the firewall can be found under VPC Network and firewall in the nav bar to the left. I recommend ufw as a firewall—it&amp;rsquo;s super simple to setup. Run &lt;code&gt;sudo apt install ufw&lt;/code&gt; to install the firewall, and then run &lt;code&gt;sudo ufw allow ssh&lt;/code&gt; to allow our ssh requests through the firewall. Then, run &lt;code&gt;sudo ufw default deny&lt;/code&gt; so that the firewall denies any traffic we don&amp;rsquo;t explicitly allow. Finally, run &lt;code&gt;sudo ufw enable&lt;/code&gt; to start the firewall.&lt;/p&gt;
&lt;p&gt;A lot of that might&amp;rsquo;ve gone over your head, but that&amp;rsquo;s fine. We secured your system and made it essentially impenetrable while you learn the ropes. Keep in mind that you&amp;rsquo;ll have to change these things if you want to, say, give a new user ssh or sudo access, or let certain traffic through the firewall if you want to run a web server.&lt;/p&gt;
&lt;p&gt;Congratulations though! If you&amp;rsquo;ve been following Chapters 4-5, you&amp;rsquo;ve set up a remote Linux virtual machine or bare metal install, given yourself encrypted access, locked down the traffic with a firewall, and now you have a perfect environment set up to learn the ins and outs of the command line. The next few chapters will likely be about specific topics, like the bash programming language or how to set up a web server, so feel free to skip around to the stuff that interests you!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../blog/linux/intro/ch6&#34;&gt;Chapter 6 - Bash &amp;amp;&amp;amp; &amp;ldquo;Extensibilty&amp;rdquo;&lt;/a&gt;&lt;/p&gt;
</description> 
    </item>
    
    <item>
      <title>Intro to Linux - Chapter 4</title>
      <link>https://skovati.dev/blog/linux/intro/ch4/</link>
      <pubDate>Tue, 25 May 2021 18:00:50 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/linux/intro/ch4/</guid>
      <description>&lt;h2 id=&#34;installing-linux&#34;&gt;Installing Linux&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Author: Skovati, Date: 2020-12-28&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In this chapter, I&amp;rsquo;ll talk about the four main ways I recommend installing and getting started with Linux, in order from most-preferred to least-preferred.&lt;/p&gt;
&lt;h3 id=&#34;option-1---installing-on-your-main-computer-most-preferred&#34;&gt;Option #1 - Installing on your main computer (Most Preferred)&lt;/h3&gt;
&lt;p&gt;This option definitely &lt;em&gt;seems&lt;/em&gt; the scariest to newcomers, but installing Linux along side whatever other operating system you have installed on your most used computer is easily the best way to get yourself to &lt;em&gt;actually&lt;/em&gt; use Linux on a daily basis, rather than installing a VM that you forget about in a week. A few things before we get started:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Backup any important information on the hard drive you want to install on―you won&amp;rsquo;t lose any data if you follow these steps, but you can never be too safe.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make sure you have enough free space on that hard drive. A Linux install like Ubuntu or Linux Mint will take up around 10 gigs, but it&amp;rsquo;s nice to have some extra space for installing packages and keeping media downloaded. I recommend having around 32-64 gigs free.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Choose your Linux distro you want to use. Ubuntu is the de facto starting place for beginners, although Linux Mint is another good recommendation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assuming you picked Ubuntu, go to the &lt;a href=&#34;https://ubuntu.com/download/desktop&#34;&gt;download&lt;/a&gt; page and grab the latest ISO for your system architecture (which is probably amd64). Alternatively, if you want to try a different &lt;em&gt;desktop environment&lt;/em&gt; (read &lt;a href=&#34;../../blog/linux/intro/ch3&#34;&gt;Chapter 3&lt;/a&gt; if you haven&amp;rsquo;t already), you can check out the different &lt;a href=&#34;https://ubuntu.com/download/flavours&#34;&gt;Ubuntu flavors&lt;/a&gt;, that include DEs like KDE Plasma, LXDE, and Budgie.&lt;/p&gt;
&lt;p&gt;Next, you&amp;rsquo;ll need a USB drive. I&amp;rsquo;d recommend at least 8 gigs, as some of these Ubuntu images can get pretty big (current release is 2.7 gigs). Make sure there isn&amp;rsquo;t anything important on it, and then download my preferred flashing utility, &lt;a href=&#34;https://www.balena.io/etcher/&#34;&gt;Balena Etcher&lt;/a&gt;. Download and run that .exe (hopefully that&amp;rsquo;s the last time you have to do &lt;em&gt;that&lt;/em&gt;), and insert your USB stick. Open Etcher, choose your USB (be careful to choose the right one), select your Ubuntu ISO, and hit flash. Once that&amp;rsquo;s done, you&amp;rsquo;ll need to make sure your computer&amp;rsquo;s BIOS is configured to boot from a USB stick before it boots from an installed hard drive; search around if you aren&amp;rsquo;t sure how to do this. Once the BIOS is configured, insert your USB and reboot. You&amp;rsquo;ll be greeted with the Ubuntu installer, which will walk you through the process. I won&amp;rsquo;t go into detail here, just make to click the &amp;ldquo;install along side existing OS&amp;rdquo; option when you&amp;rsquo;re choosing the hard drive to install to. This will partition your disks, and add your Windows install to the bootloader, so you can choose which OS to boot every time you turn your computer on. I recommend watching &lt;a href=&#34;https://www.youtube.com/watch?v=G7ffzC4S0A4&#34;&gt;this video&lt;/a&gt; to get a feel for the installation. Once the installer is done, just reboot your computer and choose Ubuntu on the GRUB bootloader screen!&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;option-2---installing-on-another-personal-machine-as-a-server&#34;&gt;Option #2 - Installing on another personal machine as a server&lt;/h3&gt;
&lt;p&gt;This option is perfect for those looking to run any server applications. Grabbing a $35 &lt;a href=&#34;https://www.raspberrypi.org/products/raspberry-pi-4-model-b/&#34;&gt;Raspberry Pi&lt;/a&gt; is a perfect way to learn about Linux servers, networking, security, SSH, hosting a website, and more. If you&amp;rsquo;re looking for a more powerful option—maybe to run a Minecraft or &lt;a href=&#34;https://www.plex.tv/&#34;&gt;Plex&lt;/a&gt; server—I highly recommend looking at used old Dell business computers like the &lt;a href=&#34;https://www.ebay.com/sch/i.html?_nkw=optiplex+7010&amp;amp;_sacat=0&#34;&gt;Optiplex&lt;/a&gt;, which is what I&amp;rsquo;m currently using for my server applications, including hosting this very blog. Once you have acquired some hardware, follow the steps above, but use a server oriented distro, like &lt;a href=&#34;https://ubuntu.com/download/server&#34;&gt;Ubuntu Server&lt;/a&gt; or &lt;a href=&#34;https://www.debian.org/&#34;&gt;Debian&lt;/a&gt;. We will cover securing a Linux server in a later chapter.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;option-3---using-a-cloud-vm-provider&#34;&gt;Option #3 - Using a cloud VM provider&lt;/h3&gt;
&lt;p&gt;This option is available for &lt;em&gt;anyone&lt;/em&gt;, no additional hardware is needed. Many companies like &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;Digital Ocean&lt;/a&gt; or Google&amp;rsquo;s &lt;a href=&#34;https://cloud.google.com/&#34;&gt;Cloud Platform&lt;/a&gt; offer free to use, small Linux VMs. These VMs really are tiny—the one I recommend is the &amp;ldquo;f1-micro&amp;rdquo;, which has one shared CPU core and 500 megs of RAM. While this isn&amp;rsquo;t much, it&amp;rsquo;s plenty to learn the basics of the Linux command line, and enough to run a simple website or VPN from.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll walk through the steps to set up this VM on Google Cloud:&lt;/p&gt;
&lt;p&gt;First, either sign in with your existing account, or make a new account &lt;a href=&#34;https://console.cloud.google.com/&#34;&gt;here&lt;/a&gt;. Make a new project at the top, called something memorable like &amp;ldquo;Linux VM&amp;rdquo; and select it. Then, on the left side, select Compute Engine. Select your project, add your payment information (you won&amp;rsquo;t be billed anything though), and the hit create VM. Under machine configuration, choose generation N1, and under Machine type, choose f1-micro. GCP gives everyone 744 free hours of f1-micro usage per month, which is exactly 24 hours a day * 31 days in a month—so this VM is indefinitely free for you to use. You also get $300 free credit towards other GCP services if you want more horsepower. Next, under Boot Disk, I recommend choosing either Ubuntu Server or Debian 10. Ubuntu Server is going to be easier for newcomers, while Debian has less configured out of the box. Then, hit create and wait a few seconds. Soon your could VM will be up and running.&lt;/p&gt;
&lt;p&gt;
&lt;figure&gt;
  &lt;img src=&#34;../../vm.png&#34; alt=&#34;&#34; /&gt;
&lt;/figure&gt;


&lt;/p&gt;
&lt;p&gt;Go back to your VM instances page, and you should see your new server. There are a handful of ways to connect to this server: SSH through the GCP interface, using the gcloud command line tool, or SSHing manually through a program of your choice. I recommend learning how to access it from a ssh client, but you should use the GCP ssh interface at least once to see what your username is on the VM. Both Linux and Windows have an SSH client built into the terminal and PowerShell respectively. If you&amp;rsquo;re familiar with SSH, generate a key pair and continue reading, if not, skip ahead to the first part of &lt;a href=&#34;../../linux/intro/ch5&#34;&gt;Chapter 5&lt;/a&gt; where I talk about what SSH is and why you should use SSH keys.&lt;/p&gt;
&lt;p&gt;Once you have an ssh key pair generated, you&amp;rsquo;ll have to add your public key to the GCP VMs whitelist. This is done by clicking on your VM in the VM instance list, and hitting edit on the top bar. Scroll down to the SSH key section, hit view and edit, and paste your ssh public key in here. Now, you should be able to access your VM by typing &lt;code&gt;ssh your-google-username@the-vms-ip-listed-on-the-instances-page&lt;/code&gt; and boom! Remote secure shell access. Once you have this working, move onto the other parts of &lt;a href=&#34;../../linux/intro/ch5&#34;&gt;Chapter 5&lt;/a&gt; where I talk about other server configuration.&lt;/p&gt;
&lt;p&gt;
&lt;figure&gt;
  &lt;img src=&#34;../../ssh.png&#34; alt=&#34;&#34; /&gt;
&lt;/figure&gt;


&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;option-4---running-a-linux-vm-least-preferred&#34;&gt;Option #4 - Running a Linux VM (Least Preferred)&lt;/h3&gt;
&lt;p&gt;I have nothing against running a VM, I just think it&amp;rsquo;s far too easy to install it once and forget about it after a week compared to installing it on your own machine or buying a Raspberry Pi. That being said, using a VM service like Oracle&amp;rsquo;s &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt; is a fool-proof way to quickly get a Linux environment up and running. This is perfect if you want to try out different distros or desktop environments, or just want to see what Linux is about before installing it on a personal machine. I won&amp;rsquo;t go into detail about how to setup a VM here, there are many other tutorials online.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../blog/linux/intro/ch5&#34;&gt;Chapter 5 - Configuring Your Linux Server&lt;/a&gt;&lt;/p&gt;
</description> 
    </item>
    
    <item>
      <title>Intro to Linux - Chapter 3</title>
      <link>https://skovati.dev/blog/linux/intro/ch3/</link>
      <pubDate>Tue, 25 May 2021 18:00:49 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/linux/intro/ch3/</guid>
      <description>&lt;h2 id=&#34;linux-terminology---distros-package-managers-and-more&#34;&gt;Linux Terminology - Distros, Package Managers, and More&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Author: Skovati, Date: 2020-12-26&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;distros&#34;&gt;Distros&lt;/h3&gt;
&lt;p&gt;So, say you wanted to install Microsoft Windows on a new computer. You&amp;rsquo;d go to the official &lt;a href=&#34;https://www.microsoft.com/en-us/software-download/windows10ISO&#34;&gt;Windows download&lt;/a&gt; page, download that &lt;em&gt;one&lt;/em&gt; specific ISO, burn it to a USB or DVD, and insert it into your computer. The installation process for Linux is quite similar, except instead of there being one official download, there are &lt;em&gt;thousands&lt;/em&gt; of different distributions of Linux, know as distros. The only thing each of these distros have in common is that they all use some form of the Linux kernel. Some have different package managers (which we&amp;rsquo;ll get to shortly), different versions of the kernel, different core utilities (like the GNU system I talked about last chapter), different release schedules, or different initialization systems. A common behavior with these distros, since all the code is free and open source, is &amp;ldquo;forking&amp;rdquo;, where a new distro uses an existing distro as a base. An example of this is the relationship between Debian and Ubuntu, two very popular distros. Since Ubuntu is based on Debian, anything written for Debian will also work out of the box on Ubuntu. This relationship means that you can have interoperability between distros, and it limits fragmentation within the ecosystem, but still offers thousands of choices for the user on which flavor of Linux they want to install.&lt;/p&gt;
&lt;p&gt;Here I will give a small summary of the most popular distros and their derivatives. As previously mentioned, there are thousands of distros, but a dozen or so hold the vast majority of the user base.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.debian.org/&#34;&gt;Debian&lt;/a&gt;: The grand-daddy of distros. Debian 0.01, the first release, came out all the way back in 1993, &lt;em&gt;before&lt;/em&gt; the first 1.0 Linux kernel release. Because of this long history, Debian is likely the most forked distro of all time. It uses the apt package manager, and has stable releases about every 2 years which use a Long Term Support (LTS) version of the Linux kernel, meaning it&amp;rsquo;s perfect for server applications. This is my personal server distro choice, and is what this blog is hosted on.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://ubuntu.com/&#34;&gt;Ubuntu&lt;/a&gt;: The most popular Debian based distro, as well as the most popular Linux distro &lt;em&gt;period&lt;/em&gt;. Since it is based on Debian, it also uses the apt package manager, but releases a new image every 6 months, and is more lenient with updating new packages, meaning it&amp;rsquo;s a more &amp;ldquo;fresh&amp;rdquo; version of Debian. For example, Debian, since it&amp;rsquo;s focused on stability and security, might only have version 80 of Firefox in the repositories with security updates only, but Ubuntu would have the latest Firefox version 84.2, with all new features, meaning it is more sutible for desktop users. Every two years, Ubuntu releases a LTS version, just like Debian. The current LTS is Ubuntu 20.04 LTS, which runs on my Raspberry Pi. Ubuntu is perfect for newcomers as they make it a design goal to be easy to download, install, and use.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://linuxmint.com/&#34;&gt;Linux Mint&lt;/a&gt;: Based on Ubuntu, Linux Mint aims to be even &lt;em&gt;more&lt;/em&gt; user-friendly than Ubuntu, by removing some of Ubuntu&amp;rsquo;s questionable decisions and offering many different desktop environment flavors. This is the distro I recommend for beginners.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.raspberrypi.org/software/&#34;&gt;Raspberry Pi OS&lt;/a&gt;: Debian based distro meant specifically for Raspberry Pis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tails.boum.org/&#34;&gt;Tails OS&lt;/a&gt;: Debian based, security and privacy focused distro. Mainly used live on USB sticks to anonymously access the Internet through the &lt;a href=&#34;https://www.torproject.org/&#34;&gt;Tor&lt;/a&gt; Network. Perfect for journalists, those with government-restricted Internet access, or those who wish to access the Dark Web. Not recommended for daily use or for beginners.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux&#34;&gt;Red Hat Enterprise Linux&lt;/a&gt;: Red Hat, an IBM subsidiary, makes an enterprise focused Linux distro known as RHEL. Uses the dnf package manager. Perfect for servers and mission critical software deployments, RHEL is open-source, but you can pay an optional fee for on-demand enterprise-grade tech support.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://getfedora.org/&#34;&gt;Fedora&lt;/a&gt;: Technically, RHEL is based on Fedora, but they share most of the same source code. When Red Hat wants to add a new feature, it first enters the Fedora distro as a sort of testing ground for the feature. Because of this, Fedora carries very up to date software and is perfect for desktop use. If a feature is deemed ready for the super stable and security focused RHEL, it gets added to a new version of RHEL a few months down the line. This is my recommended desktop distro for people who are familiar with Linux, but don&amp;rsquo;t want to mess around with configuring some of the more advanced distros below.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.centos.org/&#34;&gt;CentOS&lt;/a&gt;: Before December 2020, CentOS used to be an exact clone of RHEL, with the branding and paywalls removed, making it perfect for enthusiast home servers. Unfortunately, Red Hat bought out the CentOS project, and has recently turned it into more of a testing ground like Fedora, making it useless for many who wanted a stable server OS without the RHEL license subscription. Currently, one of my home servers runs CentOS 8, but I will be moving it to a different platform because of this news.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://rockylinux.org/&#34;&gt;Rocky Linux&lt;/a&gt;: Essentially a clone of the CentOS project since Red Hat shut that one down. Currently has no stable release but I will be transitioning to this platform once they release a 1.0.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://archlinux.org/&#34;&gt;Arch Linux&lt;/a&gt;: Arch is a rolling release distro, which means as soon as a new version of software is available, like Firefox 85 or Bash 5.1, it will be added to the Arch repositories. Uses the pacman package manager. Arch is considered &amp;ldquo;bleeding-edge&amp;rdquo; because of this; you always have the latest version of software on Arch. This is in contrast with the distros above, as those software packages are only updated based on the release schedule of the distro, meaning Ubuntu won&amp;rsquo;t get the latest version of Bash for a few months, and Debian won&amp;rsquo;t get it for years. Arch also doesn&amp;rsquo;t have an installer, meaning the user has to partition disks, make filesystems, bootstrap the package manager, and install all of their desired software manually, making it a much more advanced distro. This is what I currently use on desktop, and I recommend it to any advanced Linux user who craves the ability to customize any and every part of their system.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://manjaro.org/&#34;&gt;Manjaro&lt;/a&gt;: Essentially a pre-configured version of Arch, so you don&amp;rsquo;t have to worry about manually installing and getting things configured. Perfect for those who want bleeding-edge software like developers or enthusiasts without the hassle of installing Arch.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Other more obscure distros worth mentioning&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.gentoo.org/&#34;&gt;Gentoo&lt;/a&gt;: Sourced based distro, meaning every piece of software you install must be manually compiled. A pain in the ass to install and configure, but offers near infinite customizability because of this.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.alpinelinux.org/&#34;&gt;Alpine&lt;/a&gt;: Linux as small and lightweight as possible, only takes up ~100MB when installed, perfect for embedded systems or old hardware.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.opensuse.org/&#34;&gt;OpenSUSE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.slackware.com/&#34;&gt;Slackware&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg&#34;&gt;Here&lt;/a&gt; is a ridiculous look at all the different distros of Linux.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;package-managers&#34;&gt;Package Managers&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;ve been talking about these package managers like apt, dnf, and pacman, but what actually &lt;em&gt;are&lt;/em&gt; they? I think the best way to explain it is to compare the software installation process in Linux vs Windows. So, you are likely familiar with how to install something on Windows: you open up Microsoft Edge, suffer through a Bing search to find the Google Chrome installation page, download the .exe file, and run it as an administrator, which installs Chrome on your machine for you. It is &lt;em&gt;way easier&lt;/em&gt; on Linux. Essentially, each distro has what are called repositories, which hold the files for tens of thousands of different packages of software made specifically for that distro. So, to install chrome on something like Ubuntu, you would just type &lt;code&gt;sudo apt install google-chrome&lt;/code&gt; in the terminal, apt (the package manager on Debian/Ubuntu) would run its magic, and a few seconds later Chrome would be fully installed on your system, no downloading random .exes from the internet and running them blindly. For what it&amp;rsquo;s worth, you can still manually install things if it happens to not be in your distro&amp;rsquo;s repos.&lt;/p&gt;
&lt;p&gt;This style of package management has many pros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;No downloading random installers from the internet and running them with admin privileges, packages are instead scrutinized and validated by package managers for the distro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No wasting time searching the internet and clicking around in a downloads folder for an installer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All installed packages can be checked for updates simultaneously with a command like &lt;code&gt;sudo apt update&lt;/code&gt;, rather than relying on the software itself to have a built in updater, or just running out of date software since you&amp;rsquo;re too lazy to download a new exe.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Package managers automatically link and install shared dependencies to optimize disk space.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Because Linux is modular by design and each program does one thing and one things only, system updates are administered through package managers. In contrast, Windows has to release a whole new version and force you to restart just to add a feature to File Manager or Edge. No more &amp;ldquo;Updating Windows&amp;hellip;&amp;rdquo; screens while you&amp;rsquo;re trying to look something up quick on your laptop. Even the kernel is updated through package managers.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;desktop-environments-and-window-managers&#34;&gt;Desktop Environments and Window Managers&lt;/h3&gt;
&lt;p&gt;The most obvious form of customization in Linux is how the desktop looks and feels. This is the responsibility of a desktop environment, which manages windows, the dock, status bar, icons, settings menus, login pages, and more. Some popular options include &lt;a href=&#34;https://www.gnome.org/&#34;&gt;Gnome&lt;/a&gt; and &lt;a href=&#34;https://kde.org/plasma-desktop/&#34;&gt;KDE Plasma&lt;/a&gt;. When you download a distro&amp;rsquo;s ISO, they will likely give you multiple options for &amp;ldquo;flavors&amp;rdquo;, which include different DEs. So you can install Ubuntu with a Gnome DE, or install Ubuntu with KDE Plasma. Both are still Ubuntu, but will look and feel vastly different because the main visual software is by a different organization. I recommend Gnome as a starting place, but it is &lt;em&gt;very&lt;/em&gt; easy to install and switch to different ones. A &amp;ldquo;Window Manager&amp;rdquo; is essentially &lt;em&gt;just&lt;/em&gt; the part of a DE that controls the windows. Personally I just use a WM rather than a full DE, because I don&amp;rsquo;t need a fancy dock or a settings menu. I use &lt;a href=&#34;https://github.com/baskerville/bspwm&#34;&gt;bspwm&lt;/a&gt; and &lt;a href=&#34;https://github.com/polybar/polybar&#34;&gt;polybar&lt;/a&gt; for a lightweight desktop config.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;em&gt;Gnome Desktop&lt;/em&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;em&gt;My bspwm and polybar config&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;configuration-files-aka-dotfiles&#34;&gt;Configuration Files aka &amp;ldquo;Dotfiles&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;Another fantastic feature of Linux distros is that all of the configuration is held in so-called &amp;ldquo;configuration files&amp;rdquo;. Often these files reside in the users home directory (we&amp;rsquo;ll talk about filesystem organization in a later chapter) and are prefixed with a &amp;ldquo;.&amp;rdquo; like &amp;ldquo;.vimrc&amp;rdquo;, hence the nickname &amp;ldquo;dotfiles&amp;rdquo;. You can see examples of some dotfiles in my &lt;a href=&#34;https://github.com/skovati/dotfiles&#34;&gt;GitHub repo&lt;/a&gt;. These hold all of the config for my window manager, text editor, pdf and image viewer, terminal, and more. Because this config is stored in text files, I can back-up and version control them with git, and if I want to reinstall my OS or switch distros, all I have to do it clone that repo and 95% of my configuration is done already—including automatically installing important packages. Try doing that in windows where you have to manually install every piece of software and change each setting by hand with a new install. This makes Linux very portable and replaceable; my laptop&amp;rsquo;s SSD could get wiped and I wouldn&amp;rsquo;t break a sweat, because I didn&amp;rsquo;t really lose anything. You will spend a lot of time customizing these files, but it&amp;rsquo;s time well spent, as they can stay with you during your whole career.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../blog/linux/intro/ch4&#34;&gt;Chapter 4 - Installing Linux&lt;/a&gt;&lt;/p&gt;
</description> 
    </item>
    
    <item>
      <title>Intro to Linux - Chapter 2</title>
      <link>https://skovati.dev/blog/linux/intro/ch2/</link>
      <pubDate>Tue, 25 May 2021 18:00:48 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/linux/intro/ch2/</guid>
      <description>&lt;h2 id=&#34;what-is-a-linux-anyways&#34;&gt;What is a &amp;ldquo;Linux&amp;rdquo; anyways?&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Author: Skovati, Date: 2020-12-25&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This chapter &lt;em&gt;is&lt;/em&gt; optional, but highly recommended. To really get a good perspective on Linux as a whole I think some historical context is necessary. It all starts back in the 60s when MIT and AT&amp;amp;T&amp;rsquo;s Bell Labs were developing Multics, a time-sharing operating system for the GE-645 mainframe computer. That baby had dual 435kHz processors, 3 MBs of memory, could connect to 35 terminals simultaneously, and looked like this:&lt;/p&gt;
&lt;p&gt;
&lt;figure&gt;
  &lt;img src=&#34;../../GE645.jpg&#34; alt=&#34;GE-645&#34; /&gt;
  &lt;figcaption&gt;GE-645&lt;/figcaption&gt;
&lt;/figure&gt;



&lt;em&gt;GE-645&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;While Multics was probably the most influential operating system of all time, it wasn&amp;rsquo;t without its issues, and after a few years working on the project, Ken Thompson, Dennis Ritchie, and a few others decided to start over with something called &lt;em&gt;Uniplexed Information and Computing Service&lt;/em&gt; or Unics—later renamed Unix. While originally written in assembly language, it was eventually ported to be the first OS written in &lt;em&gt;C&lt;/em&gt;, a new high-level programming language also created at Bell Labs (seriously look at the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bell_Labs&#34;&gt;Wikipedia&lt;/a&gt; page for Bell Labs, they invented everything from Unix to the transistor). Unix was revolutionary, introducing hierarchical file systems, text-based applications, shell scripting, pipelining commands, devices as files, and the so-called &amp;ldquo;Unix Philosophy&amp;rdquo;. This philosophy can be summarized as &amp;ldquo;Each program should just do one thing and do it well&amp;rdquo;—meaning one program should list files in a directory, while an entirely separate program should facilitate changing directories or creating new files. This is in great contrast with a &lt;em&gt;monolithic&lt;/em&gt; design style, where one singular &lt;em&gt;File Manager&lt;/em&gt; is responsible for &lt;strong&gt;all&lt;/strong&gt; the desired behavior for creating, managing, moving, renaming, or deleting files. This increased modularity that Unix got from this philosophy allowed it to be extremely extensible and scale very well. The Unix philosophy is still often referenced today in software design—most commonly Keep It Simple Stupid.&lt;/p&gt;
&lt;p&gt;
&lt;figure&gt;
  &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Ken_Thompson_and_Dennis_Ritchie--1973.jpg/300px-Ken_Thompson_and_Dennis_Ritchie--1973.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/figure&gt;


&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Ken Thompson and Dennis Ritchie at Bell Labs&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Although Unix was revolutionary for its time, a few notable people disagreed with it being the closed-source property of AT&amp;amp;T, and thought an operating system like that should be open-source, transparent, and free for use and redistribution. One of these people was the Richard Stallman, a researcher at MIT&amp;rsquo;s AI Laboratory. Stallman believed that computer users should be free to study the source code of the programs they used, modify the source code, and redistribute their modified versions in a collaborative sense. This philosophy was later published as the &lt;a href=&#34;https://www.gnu.org/gnu/manifesto.html&#34;&gt;GNU Manifesto&lt;/a&gt;. Stallman then went to write his own GNU operating system, inspired by and compatible with the popular proprietary Unix OS. Stallman is credited with inventing the idea of &lt;em&gt;free&lt;/em&gt; or &lt;em&gt;libre&lt;/em&gt; software. To facilitate this new idea of FOSS software, he created a new &amp;ldquo;copyleft&amp;rdquo; license called the &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.html&#34;&gt;GNU Public License&lt;/a&gt; or GPL for short. Software published with this license must make its source code accessible and available to modify and redistribute for free; additionally, other software that uses GPL licensed software must itself uphold the license, thus creating a cascading effect of FOSS projects that are contributed to for the greater good by both volunteers &lt;em&gt;and&lt;/em&gt; large corporations. He and his team were able to implement all of the system and user utilities needed for a general operating system, but they were still missing a kernel by the time the 90s rolled around.&lt;/p&gt;
&lt;p&gt;So what is a &amp;ldquo;kernel&amp;rdquo; in an operating system? I&amp;rsquo;m no systems programmer, but essentially it does the translation between hardware and software in an OS. So anytime that a program is launched, it requests CPU and memory resources from the kernel; the kernel is the software that actually holds device drivers and sends instructions to the CPU and handles virtual memory for different programs. The Linux kernel also does all the filesystem work, interfaces with block devices, networks, and facilitates communication between system processes. Essentially, when you plug a USB stick into your laptop running Linux, the kernel is the software responsible for communicating with it using the USB drivers, detecting and mounting the filesystem on the drive, and sending all the serial data to and from the block device.&lt;/p&gt;
&lt;p&gt;An operating system kernel is a &lt;em&gt;lot&lt;/em&gt; of work to create, so you can understand why it was the last thing for the GNU system to implement. Luckily, a Finnish programmer by the name of Linus Torvalds came to the rescue, as he was working on a Unix-like OS kernel called Linux around the early 90s. So, the GNU system needed a Unix-like kernel, and Linux needed Unix-like userland utilities, so Richard Stallman and Linux Torvalds worked together to create what is now know as the GNU/Linux operating system, which often goes by its nickname &amp;ldquo;Linux&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;
&lt;figure&gt;
  &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/1200px-Unix_history-simple.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;/figure&gt;



&lt;a href=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/1200px-Unix_history-simple.svg.png&#34;&gt;&lt;em&gt;Flowchart&lt;/em&gt;&lt;/a&gt; &lt;em&gt;showing the history of Unix-like systems&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Today Linux is everywhere. Over 90% of the world&amp;rsquo;s cloud infrastructure runs a Linux based operating system, over 75% of the worlds phones run a Linux kernel—as Google&amp;rsquo;s Android operating system uses the Linux kernel, and &lt;strong&gt;all&lt;/strong&gt; of the worlds top 500 supercomputers run Linux. Linux runs on everything from your router to smartwatch to your car to your bluetooth speaker to the X-ray machines at the hospital. Linux is most commonly packaged into &amp;ldquo;Linux distributions&amp;rdquo; or distros for short, which we will get to in a later chapter.&lt;/p&gt;
&lt;p&gt;So, to recap, what we know as Linux today is actually result of decades of operating system forks, rewrites, and design. Window managers and web browsers inhabit the high-level, the GNU system utilities takes care of the mid-level, and the Linux kernel deals with the low-level.&lt;/p&gt;
&lt;p&gt;I would be remissed if I didn&amp;rsquo;t mention Linux&amp;rsquo;s cousins, the BSDs. I&amp;rsquo;ll keep this short, but back in the 80s when Stallman was developing his own system &lt;em&gt;based&lt;/em&gt; on Unix, some genius students and researchers at UC Berkeley were creating a direct &lt;em&gt;copy&lt;/em&gt; of the Unix system called Berkeley Software Distribution or BSD for short. The original BSD has seen many forks; today the main BSDs are FreeBSD, OpenBSD, and NetBSD. The BSDs are considered to have been a more direct implementation of the Unix philosophy, which many prefer, and it was licensed with its own BSD style license. This license doesn&amp;rsquo;t require software that uses other BSD licensed software to be licensed itself, so many companies use BSDs in order to keep their code closed source; most notably Sony&amp;rsquo;s PlayStation OS and Apples macOS and iOS are BSD based for this reason.&lt;/p&gt;
&lt;p&gt;Finally, the preamble is over, and we can get into the meat of using Linux.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../blog/linux/intro/ch3&#34;&gt;Chapter 3 - Linux Terminology - Distros, Package Managers, and More.&lt;/a&gt;&lt;/p&gt;
</description> 
    </item>
    
    <item>
      <title>Intro to Linux - Chapter 1</title>
      <link>https://skovati.dev/blog/linux/intro/ch1/</link>
      <pubDate>Tue, 25 May 2021 18:00:47 -0500</pubDate>
      
      <guid>https://skovati.dev/blog/linux/intro/ch1/</guid>
      <description>&lt;h2 id=&#34;chapter-1---why-should-i-care&#34;&gt;Chapter 1 - Why should I care?&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Author: Skovati, Date: 2020-12-24&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If I had to condense why I care about free and open source (FOSS) operating systems like Linux into one word, it would be freedom. Almost everyone values having choice in their daily lives—imagine if there was only one type of car that everyone had to use, or you could only buy one style of house. Hell, the US launched a whole revolution because we wanted freedom of religion, so why don&amp;rsquo;t people care about freedom in software? The way it currently works with popular proprietary operating systems is the designers at Microsoft or Apple decide what&amp;rsquo;s best for the general population, and then you—even as a poweruser—are stuck with those decisions unless you &lt;em&gt;really&lt;/em&gt; want to get hacky with some unsupported third-party software.&lt;/p&gt;
&lt;p&gt;So how is Linux different? Essentially &lt;em&gt;everything&lt;/em&gt; is third-party software, so it&amp;rsquo;s treated as a first-class citizen. Your text editor might be written by a completely different organization than your web browser or terminal or file manager. So, instead of Microsoft shoving Edge or Internet Explorer or Cortana down your throat, you&amp;rsquo;re free to choose whatever program fits your needs best, all the way down to which kernel, window manager, or distro you want to run.&lt;/p&gt;
&lt;p&gt;Besides freedom, there are countless other reasons to run Linux. Firstly, it&amp;rsquo;s free—both in the freedom sense and in the monetary sense. This means you don&amp;rsquo;t have to worry about losing your windows activation key or buying another key when you purchase a new computer. Linux always has been and always will be free.&lt;/p&gt;
&lt;p&gt;Linux is also open source, meaning you can view the &lt;a href=&#34;https://github.com/torvalds/linux&#34;&gt;source code&lt;/a&gt; yourself. Because of this transparent source code, you can be sure that programs you use aren&amp;rsquo;t doing anything nefarious, like constantly recording your microphone *cough* &lt;em&gt;Cortana&lt;/em&gt; or selling your personal information and habits to advertisers for profit *cough* &lt;em&gt;Google&lt;/em&gt;. Like Moxie Marlinspike, co-founder of the Signal Foundation always says, &amp;ldquo;Bad business models create bad technology.&amp;rdquo; Since Linux and other FOSS projects are driven by volunteers and donations, they don&amp;rsquo;t have to sell information or get you to pay a subscription fee to pay for the development, which is a much more sustainable business model in my view.&lt;/p&gt;
&lt;p&gt;Also, Linux is a perfect development environment. The vast majority of servers in the world run some sort of Linux, so being comfortable with the command line and Linux filesystems is of paramount importance. Developing in a similar environment to the one used in production just &lt;em&gt;makes sense&lt;/em&gt;, and Linux is that environment.&lt;/p&gt;
&lt;p&gt;Finally, I think Linux is just an interesting operating system. Windows and macOS &lt;strong&gt;don&amp;rsquo;t&lt;/strong&gt; want you to know how the inner-workings work, but Linux &lt;em&gt;does&lt;/em&gt; want you to understand. That means there is so much educational value in learning the ins and outs of Linux—you&amp;rsquo;ll learn everything from bash scripting to filesystems to disk partitioning to  compiling code manually to basics of networking and so much more. I&amp;rsquo;m passionate about Linux, you don&amp;rsquo;t hear many people saying that about Windows or macOS because there just isn&amp;rsquo;t much to be passionate &lt;em&gt;about&lt;/em&gt;. Sure computers are just tools to get more work done, but Linux is a tool that will improve &lt;em&gt;yourself&lt;/em&gt; as well.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../blog/linux/intro/ch2&#34;&gt;Chapter 2 - What is a &amp;lsquo;Linux&amp;rsquo; anyways?&lt;/a&gt;&lt;/p&gt;
</description> 
    </item>
    
  </channel>
</rss>
